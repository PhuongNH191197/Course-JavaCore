# Core stream operations

Tất cả các hoạt động của Stream được chia thành `intermediate (trung gian)` và `terminal (đầu cuối) operations` kết hợp để tạo thành đường ống dẫn.

Một đường ống dẫn luồng bao gồm một nguồn `(Collection, an array, a generator function)`, tiếp theo là không hoặc nhiều `intermediate operations` và `terminal operation`.

Đầu tiên, chúng ta khởi tạo một `List` để làm ví dụ cho các phần tiếp théo:
```java
List<String> memberNames = new ArrayList<>();
    memberNames.add("Amitabh");
    memberNames.add("Shekhar");
    memberNames.add("Aman");
    memberNames.add("Rahul");
    memberNames.add("Shahrukh");
    memberNames.add("Salman");
    memberNames.add("Yana");
    memberNames.add("Lokesh");
```

## 1. Intermediate Operations
`Intermediate operations` có thể được thêm vào một Stream theo phương thức:
- filter()
- map()
- flatMap()
- distinct()
- sorted()
- peek()
- limit()
- skip()

Tất cả các `intermediate operations` đều là lazy (trì hoãn), do đó chúng không được thực hiện cho đến khi xử lý thực sự cần thiết. Về cơ bản, các `intermediate operations` trả về một Stream mới. Việc thực thi `intermediate operations` không thực sự thực hiện bất kỳ thao tác nào, mà thay vào đó tạo một Stream mới.

> Lưu ý Stream được tạo từ `intermediate operations` sẽ không được thực hiện cho đến khi `terminal operations` được thực hiện.

> Do đó, quá trình truyền tải của Stream không bắt đầu cho đến khi `terminal operation` được thực thi.

Đó là thuộc tính rất quan trọng, đặc biệt quan trọng đối với các luồng vô hạn - bởi vì nó cho phép chúng ta tạo ra các luồng sẽ thực sự được gọi chỉ khi một `terminal operation` được gọi.

## 2. Terminal Operations
Các `terminal operation` sẽ duyệt (thực thi) 1 stream để trả về 1 kết quả. Sau khi `terminal operation` được thực hiện, stream sẽ được xét như là đã được tiêu thụ, không còn được sử dụng nữa. Trong trường hợp bạn vẫn muốn duyệt cùng kiểu tập hợp dữ liệu đó, bạn cần phải quay lại data source và tạo ra stream mới.

Các `Terminal Operations` cơ bản là:
- forEach()
- forEachOrdered()
- reduce()
- collect()
- toArray()
- min()
- max()
- count()

Mỗi hoạt động này sẽ kích hoạt thực hiện tất cả các `intermediate operations`. Hai đặc điểm chính của `terminal operation`:

- Chúng có thể trả về một giá trị nguyên thủy, một kiểu cụ thể (`Optional` value object), hoặc void (tạo hiệu ứng phụ).
- `terminal operation` luôn là hoạt động cuối cùng trong một đường ống Stream.

### Ví dụ:

#### - forEach()

Phương thức này giúp lặp lại trên tất cả các phần tử của Stream và thực hiện một số thao tác. Thao tác được chuyển thành tham số biểu thức lambda.

Đối với luồng song song `parallel stream`, hoạt động này không đảm bảo thứ tự phần tử của Stream, vì làm như vậy sẽ mất đi lợi ích của tính song song.
```java
memberNames.forEach(System.out::println);
```

#### - forEachOrdered()

`forEachOrdered()` sẽ xử lý các phần tử của Stream theo thứ tự được chỉ định bởi nguồn của nó, bất kể Stream có tuần tự hay song song hay không. Cũng có nghĩa là nó làm mất đi lợi ích của tính song song.
```java
Stream.of("AAA","BBB","CCC").parallel().forEach(s -> System.out.println("Output: "+s));
// output
Output: BBB
Output: CCC
Output: AAA

Stream.of("AAA","BBB","CCC").parallel().forEachOrdered( s-> System.out.println("Output: "+s));
// output
Output: AAA
Output: BBB
Output: CCC
```

#### - reduce()

Phương thức `reduce()` sử dụng khi muốn thao tác giữa các phần tử trong Stream để thực hiện phép tính nào đó. Ví dụ tính tổng các số nguyên của một list collection, hay tìm ra giá trị max của một collection

Nối chuỗi String
```java
Optional<String> reduced = memberNames.stream()
                    .reduce((s, name) -> s + "#" + name);
                    
reduced.ifPresent(System.out::println);
 
// output 
Amitabh#Shekhar#Aman#Rahul#Shahrukh#Salman#Yana#Lokesh
```

Tính tổng các số nguyên
```java
List<Integer> numbers = Arrays.asList(1, 2, 23, 4, 7, 61, 72, 88);
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
System.out.println("Sum of all list: " + sum);
```

Tìm giá trị min - max
```java
List<Integer> numbers = Arrays.asList(1, 2, 23, 4, 7, 61, 72, 88);
int max = numbers.stream().reduce(0, Integer::max);
System.out.println("Maximum is: " + max);

int min = numbers.stream().reduce(0, Integer::min);
System.out.println("Maximum is: " + min);
```

## 3. Short-circuit operations
Mặc dù, các hoạt động Stream được thực hiện trên tất cả các phần tử bên trong một bộ sưu tập thỏa mãn một `predicate`, nhưng đôi khi bạn muốn phá vỡ vòng lặp bất cứ khi nào khi gặp phải một phần tử phù hợp trong quá trình lặp. Hãy xem ví dụ về hai phương pháp như vậy:

- anyMatch()
- allMatch()
- noneMatch()
- findFirst()
- findAny()
